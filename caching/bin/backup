import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;

public class Main {

	public static void main(String[] args) throws IOException {
		Kattio io = new Kattio(System.in);
		int cacheSpace = io.getInt();
		int numObjects = io.getInt();
		int numAccesses = io.getInt();
		List<Integer> accesses = new ArrayList<Integer>();
		for (int i = 0; i < numAccesses; i++) {
			accesses.add(io.getInt());
		}
		io.flush();
		System.out.println(getOptimalCacheWrites(cacheSpace, numObjects, accesses));
	}

	private static int getOptimalCacheWrites(int cacheSpace, int numObjects, List<Integer> accesses) {
		Map<Integer, Queue<Integer>> occurrences = getOccurances(accesses);
		Map<Integer, Boolean> cache = new HashMap<Integer, Boolean>();
		Queue<CacheObject> nextOccurrences = new PriorityQueue<CacheObject>();
		int cacheWrites = 0, accessIndex = 0;
		while (accessIndex < accesses.size()) {
			int currentObject = accesses.get(accessIndex);
			accessIndex++;
			occurrences.get(currentObject).poll();
			if (cacheWrites < cacheSpace) {
				if (!cache.containsKey(currentObject)) {
					nextOccurrences.add(new CacheObject(currentObject, getNextOccurrence(currentObject, occurrences)));
					cache.put(currentObject, true);
					cacheWrites++;
				}
			} else {
				if (!(cache.containsKey(currentObject) && cache.get(currentObject) == true)) {
					if (accessIndex == 13) {
						System.out.println(cache);
						derp = true;
					}
					int objectToReplace = getObjectToReplace(occurrences, nextOccurrences);
					derp = false;
					if (accessIndex == 13) {
						System.out.println("objectToReplace: " + objectToReplace);
						System.out.println("nextOccurence of 4: " + getNextOccurrence(4, occurrences));
						System.out.println("nextOccurence of 2: " + getNextOccurrence(2, occurrences));
					}
					nextOccurrences.add(new CacheObject(currentObject, getNextOccurrence(currentObject, occurrences)));
					cache.put(currentObject, true);
					cache.put(objectToReplace, false);
					cacheWrites++;
				}
			}
		}
		return cacheWrites;
	}

	private static boolean derp = false;

	private static int getObjectToReplace(Map<Integer, Queue<Integer>> occurrences, Queue<CacheObject> nextOccurrences) {
		while (!nextOccurrences.isEmpty()) {
			if (derp) {
				for (int i = 0; i < 3; i++) {
					CacheObject objectASD = nextOccurrences.poll();
					int nextOccurrenceASD = getNextOccurrence(objectASD.getObjectNumber(), occurrences);
					System.out.println("size: " + nextOccurrences.size() + "obj: " + objectASD.getObjectNumber() + "\t" + objectASD.getNextAccess());
					System.out.println("FO REALZ:" + nextOccurrenceASD);
				}
			}
			CacheObject object = nextOccurrences.poll();
			int nextOccurrence = getNextOccurrence(object.getObjectNumber(), occurrences);
			if (nextOccurrence == object.getNextAccess() || nextOccurrence == Integer.MAX_VALUE)
				return object.getObjectNumber();
			nextOccurrences.add(new CacheObject(object.getObjectNumber(), nextOccurrence));
		}
		return -1;
	}

	private static int getNextOccurrence(int currentObject, Map<Integer, Queue<Integer>> occurrences) {
		if (occurrences.get(currentObject).isEmpty())
			return Integer.MAX_VALUE;
		else
			return occurrences.get(currentObject).peek();
	}

	private static Map<Integer, Queue<Integer>> getOccurances(List<Integer> accesses) {
		Map<Integer, Queue<Integer>> occurances = new HashMap<Integer, Queue<Integer>>();
		for (int i = 0; i < accesses.size(); i++) {
			if (occurances.containsKey(accesses.get(i))) {
				occurances.get(accesses.get(i)).add(i);
			} else {
				Queue<Integer> list = new LinkedList<Integer>();
				list.add(i);
				occurances.put(accesses.get(i), list);
			}
		}
		return occurances;
	}
}


public class CacheObject implements Comparable<CacheObject> {
	private int objectNumber;
	private int nextAccess;

	public CacheObject(int objectNumber, int nextAccess) {
		this.objectNumber = objectNumber;
		this.nextAccess = nextAccess;
	}

	public int getNextAccess() {
		return nextAccess;
	}

	public void setNextAccess(int nextAccess) {
		this.nextAccess = nextAccess;
	}

	public int getObjectNumber() {
		return objectNumber;
	}

	@Override
	public boolean equals(Object o) {
		if (o instanceof CacheObject && objectNumber == ((CacheObject) o).getObjectNumber() && nextAccess == ((CacheObject) o).getNextAccess())
			return true;
		return false;

	}

	@Override
	public int compareTo(CacheObject object) {
		if (nextAccess < object.getNextAccess())
			return 1;
		if (nextAccess == object.getNextAccess())
			return 0;
		return -1;
	}

}
